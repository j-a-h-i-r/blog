<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[A simple blog]]></title><description><![CDATA[A simple blog]]></description><link>https://blog.jahir.me</link><generator>GatsbyJS</generator><lastBuildDate>Mon, 16 Aug 2021 15:19:13 GMT</lastBuildDate><item><title><![CDATA[Setting up a react app with API using dokku]]></title><description><![CDATA[I’ve recently discovered dokku. I was setting up some of my personal projects in a DigitalOcean droplet like a caveman and was looking for…]]></description><link>https://blog.jahir.me/4-dokku/</link><guid isPermaLink="false">https://blog.jahir.me/4-dokku/</guid><pubDate>Fri, 09 Jul 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;I’ve recently discovered &lt;a href=&quot;https://dokku.com/&quot;&gt;dokku&lt;/a&gt;. I was setting up some of my personal projects in a DigitalOcean droplet like a caveman and was looking for alternative. Dokku appeared in my search results like a blessing.&lt;/p&gt;
&lt;p&gt;I followed the &lt;a href=&quot;https://dokku.com/docs/deployment/application-deployment/&quot;&gt;getting started guide&lt;/a&gt; and set up the demo application in my server easily. So I then moved to host one of my react projects in cloud.&lt;/p&gt;
&lt;p&gt;I looked around to see if there is any ready-made solution supported by Dokku. But I could not find any solution specific to react. Dokku provides a &lt;a href=&quot;https://github.com/dokku/heroku-buildpack-nginx&quot;&gt;buildpack for deploying a static site&lt;/a&gt;. It also supports building the static assets! While that is nice, it was difficult to deploy the react app along with the API.&lt;/p&gt;
&lt;p&gt;I found &lt;a href=&quot;https://github.com/heroku/heroku-buildpack-static&quot;&gt;heroku-buildpack-static&lt;/a&gt; which is provided by Heroku. It is way more easily configurable and fit my use case perfectly.&lt;/p&gt;
&lt;h3&gt;Setting up the stage&lt;/h3&gt;
&lt;p&gt;We actually need 2 buildpacks. First buildpack will build the react app and the second one will deploy the static files.&lt;/p&gt;
&lt;p&gt;So, add a &lt;code class=&quot;language-text&quot;&gt;.buildpacks&lt;/code&gt; file and put the following content in the file&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;https://github.com/heroku/heroku-buildpack-nodejs.git
https://github.com/heroku/heroku-buildpack-static.git&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;https://github.com/heroku/heroku-buildpack-nodejs.git&lt;/code&gt; is the buildpack for working with NodeJS files. As the react app uses NodeJS, simply adding this buildpack will take care of building the application.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;https://github.com/heroku/heroku-buildpack-static.git&lt;/code&gt; buildpack will take care of configuring the nginx and other stuffs after the app is built.&lt;/p&gt;
&lt;h3&gt;Configuring the deployment&lt;/h3&gt;
&lt;p&gt;The cool thing about &lt;code class=&quot;language-text&quot;&gt;heroku-buildpack-static&lt;/code&gt; is that it supports &lt;a href=&quot;https://github.com/heroku/heroku-buildpack-static#configuration&quot;&gt;lots of different settings&lt;/a&gt;. We just need to add a &lt;code class=&quot;language-text&quot;&gt;static.json&lt;/code&gt; file at the root directory of the app.&lt;/p&gt;
&lt;p&gt;Here’s a simple example,&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre style=&quot;counter-reset: linenumber 0&quot; class=&quot;language-javascript line-numbers&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token string&quot;&gt;&quot;root&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;build/&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token string&quot;&gt;&quot;proxies&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;/api/&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token string&quot;&gt;&quot;origin&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;https://example.com/api&quot;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot; style=&quot;white-space: normal; width: auto; left: 0;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;root&lt;/code&gt; specifies the root folder of the static files. React apps by default output the build files at the &lt;code class=&quot;language-text&quot;&gt;build&lt;/code&gt; directory. So this will configure the nginx to treat the &lt;code class=&quot;language-text&quot;&gt;build&lt;/code&gt; folder as the root.&lt;/p&gt;
&lt;p&gt;The &lt;code class=&quot;language-text&quot;&gt;proxies&lt;/code&gt; option makes it easy to communicate with the API and avoid CORS. The example above will proxy all &lt;code class=&quot;language-text&quot;&gt;&amp;lt;app-url&gt;/api&lt;/code&gt; calls to &lt;code class=&quot;language-text&quot;&gt;https://example.com/api&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This makes it really easy to separately deploy the fronend and backend.&lt;/p&gt;
&lt;p&gt;What I would really like is to avoid specifying a public URL. My backend is also running in the same server. So, I would like to proxy my calls to the internal URL of the backend without routing it through a public URL.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Running scripts inside externally loaded iframe from Chrome Extension]]></title><description><![CDATA[Recently I worked on developing a Chrome Extension. The extension is quite simple. It presents some fields in the popup. Some pre-configured…]]></description><link>https://blog.jahir.me/3-chrome-extension-iframe/</link><guid isPermaLink="false">https://blog.jahir.me/3-chrome-extension-iframe/</guid><pubDate>Fri, 11 Jun 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Recently I worked on developing a Chrome Extension. The extension is quite simple. It presents some fields in the popup. Some pre-configured inputs in the current tab can be autofilled by clicking on a button.&lt;/p&gt;
&lt;h4&gt;Problem 1&lt;/h4&gt;
&lt;p&gt;The page is rendered using React. So doing the following does not work&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const inputSelector = &apos;input#id&apos;;
const inputElement = document.querySelector(inputSelector);
inputElement.value = &apos;some-value&apos;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Luckily the solution to this problem is simple,&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const inputSelector = &apos;input#id&apos;;
const inputElement = document.querySelector(inputSelector);
inputElement.select();
inputElement.execCommand(&apos;insertText&apos;, false, &apos;some-value&apos;);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Problem 2&lt;/h4&gt;
&lt;p&gt;Now comes the biggest problem. The input elements are loaded via &lt;code class=&quot;language-text&quot;&gt;iframe&lt;/code&gt;. So trying to select an element using &lt;code class=&quot;language-text&quot;&gt;querySelector&lt;/code&gt; from the root of the page will result in the following error&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Uncaught DOMException: Blocked a frame with origin ”&lt;a href=&quot;https://orgigin.of.the.active.tab&quot;&gt;https://orgigin.of.the.active.tab&lt;/a&gt;” from accessing a cross-origin frame.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This error occurs beacuse browsers prevent JavaScript from accessing elements that do not belong to the origin. This is an important security feature.&lt;/p&gt;
&lt;p&gt;So how to overcome this restriction? The solution is to instruct Chrome to run our script directly inside the &lt;code class=&quot;language-text&quot;&gt;iframe&lt;/code&gt;. Chrome scripts are usually run the following way,&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;chrome.scripting.executeScript({
  target: {tabId: tabId},
  function: functionToInject,
},
  () =&gt; { ... });&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here &lt;code class=&quot;language-text&quot;&gt;tabId&lt;/code&gt; is the tab where the script will be inserted, which is usually the active tab. The code above will inject the &lt;code class=&quot;language-text&quot;&gt;functionToInject&lt;/code&gt; function inside the root frame. Chrome supports passing a &lt;code class=&quot;language-text&quot;&gt;frameIds&lt;/code&gt; property in &lt;code class=&quot;language-text&quot;&gt;target&lt;/code&gt; to target specific frame on the page.&lt;/p&gt;
&lt;p&gt;So, how to find the ID of the frames? Well Chrome provides an API for that. The &lt;code class=&quot;language-text&quot;&gt;webNavigation&lt;/code&gt; API. The following code will fetch all the frames of the current page,&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;chrome.webNavigation.getAllFrames({
  tabId: tabId
}, (frames) =&gt; {
  // frames contains an array of frames in the current page.
  // frameId contains the id of the frame
})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So, if we combine these two APIs, we can inject a script directly into an external frame and fill an input without violating the cross-origin frame restriction.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;chrome.webNavigation.getAllFrames({tabId: tabId}, (frames) =&gt; {
  const frameIds = frames
  .map((f) =&gt; f.frameId);

  chrome.scripting.executeScript({
    target: { tabId: tabId, frameIds: frameIds },
    function: functionToInject,
  });
});&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This will inject the function in all frames found in the page. Ofcourse further filters can be applied to the frames to target more specific frames.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Using docker with elastic beanstalk is not fun!]]></title><description><![CDATA[I have a fullstack application using the JS stack. It uses express for the server and Angular on the front end. This is sort of a pet…]]></description><link>https://blog.jahir.me/2-elastic-beanstalk-docker/</link><guid isPermaLink="false">https://blog.jahir.me/2-elastic-beanstalk-docker/</guid><pubDate>Fri, 25 Dec 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;I have a fullstack application using the JS stack. It uses express for the server and Angular on the front end. This is sort of a pet project and I like to do some experiments with it. One of them is to enable automatic deployment on it.&lt;/p&gt;
&lt;p&gt;The server and client codes resided on their own repo. What I did for deployment is to generate the build artifacts using angular on my local machine. Then I manually copied them over to my server repo and served the static files from there. This is very manual process and I needed to automate it.&lt;/p&gt;
&lt;p&gt;I used elastic beanstalk for automatically deploying my application. For the automating process, I converted my project into a monorepo, so that I can build the code upon push to master. While I was at it, I thought why not use docker.&lt;/p&gt;
&lt;p&gt;I created a docker environment on elastic beanstalk. I setup my Dockerfile and docker-compose configuration. It worked well for the first few times. But after that it was all just a mess. The biggest problem was that the environment kept crashing every time I deployed changes. And during the crash, I could not access the logs. It took almost 30 minutes each time the eb environment crashed. This makes the debugging process extremely frustating. After 2 days of trying to make it work, I gave up.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Buying a domain for the first time]]></title><description><![CDATA[I got invited to participate in a survey on LinkedIn. It was about ThymeLeaf. I used ThymeLeaft for a bit during my first job. So, I decided…]]></description><link>https://blog.jahir.me/1-buying-domain/</link><guid isPermaLink="false">https://blog.jahir.me/1-buying-domain/</guid><pubDate>Wed, 12 Aug 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;I got invited to participate in a survey on LinkedIn. It was about ThymeLeaf. I used ThymeLeaft for a bit during my first job. So, I decided to do it. The survey was on G2 and I got a $10 virtual card as a reward for participating.&lt;/p&gt;
&lt;p&gt;I was thinking of things where I could use this virtual card. It’s an international card, so I could use it in most of the sites I wanted to. The very first thing I did was to sign up for AWS 1 year free tier account. I also tried to sign up for GCP, but unfortunately they don’t support Virtual Cards.&lt;/p&gt;
&lt;p&gt;Buying a custom domain seemed to be the perfect thing for me. So, I headed on to GoDaddy and looked what’s available. After some digging, I settled for jahir.me. It was cheap, short and easy to remember. I got it for like 3$ for 1 year.&lt;/p&gt;
&lt;p&gt;This was the first time I was managing a domain and all the things seemed pretty complex. I still have to Google everytime I need to change a CNAME record. I found GoDaddy’s domain management interface pretty poorly designed so I moved my domain management to Cloudfare. Cloudflare’s interface feels quite intuitive to me. I also got free SSL which means https for my website for mee. Sweet deal!&lt;/p&gt;
&lt;p&gt;For future domains, I’ll probably buy it directly from Cloudflare or use Namecheap. These seem to be the better options with much friendlier tools.&lt;/p&gt;
&lt;p&gt;Ultimately, having a custom domain is pretty sweet. I host my site on GitHub. This blog is also hosted on GitHub. I have also configured an email server with Zoho for experimenting, and it was easy to set up. And all of this was done for about 3$. This feels like pretty good utility for the amount spent!&lt;/p&gt;</content:encoded></item></channel></rss>