{"componentChunkName":"component---src-templates-blog-post-js","path":"/3-chrome-extension-iframe/","result":{"data":{"site":{"siteMetadata":{"title":"A simple blog"}},"markdownRemark":{"id":"97cbcc47-ea42-5c85-8e01-81b04cc85a45","excerpt":"Recently I worked on developing a Chrome Extension. The extension is quite simple. It presents some fields in the popup. Some pre-configured inputs in the…","html":"<p>Recently I worked on developing a Chrome Extension. The extension is quite simple. It presents some fields in the popup. Some pre-configured inputs in the current tab can be autofilled by clicking on a button.</p>\n<h4>Problem 1</h4>\n<p>The page is rendered using React. So doing the following does not work</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const inputSelector = 'input#id';\nconst inputElement = document.querySelector(inputSelector);\ninputElement.value = 'some-value';</code></pre></div>\n<p>Luckily the solution to this problem is simple,</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const inputSelector = 'input#id';\nconst inputElement = document.querySelector(inputSelector);\ninputElement.select();\ninputElement.execCommand('insertText', false, 'some-value');</code></pre></div>\n<h4>Problem 2</h4>\n<p>Now comes the biggest problem. The input elements are loaded via <code class=\"language-text\">iframe</code>. So trying to select an element using <code class=\"language-text\">querySelector</code> from the root of the page will result in the following error</p>\n<blockquote>\n<p>Uncaught DOMException: Blocked a frame with origin ”<a href=\"https://orgigin.of.the.active.tab\">https://orgigin.of.the.active.tab</a>” from accessing a cross-origin frame.</p>\n</blockquote>\n<p>This error occurs beacuse browsers prevent JavaScript from accessing elements that do not belong to the origin. This is an important security feature.</p>\n<p>So how to overcome this restriction? The solution is to instruct Chrome to run our script directly inside the <code class=\"language-text\">iframe</code>. Chrome scripts are usually run the following way,</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">chrome.scripting.executeScript({\n  target: {tabId: tabId},\n  function: functionToInject,\n},\n  () => { ... });</code></pre></div>\n<p>Here <code class=\"language-text\">tabId</code> is the tab where the script will be inserted, which is usually the active tab. The code above will inject the <code class=\"language-text\">functionToInject</code> function inside the root frame. Chrome supports passing a <code class=\"language-text\">frameIds</code> property in <code class=\"language-text\">target</code> to target specific frame on the page.</p>\n<p>So, how to find the ID of the frames? Well Chrome provides an API for that. The <code class=\"language-text\">webNavigation</code> API. The following code will fetch all the frames of the current page,</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">chrome.webNavigation.getAllFrames({\n  tabId: tabId\n}, (frames) => {\n  // frames contains an array of frames in the current page.\n  // frameId contains the id of the frame\n})</code></pre></div>\n<p>So, if we combine these two APIs, we can inject a script directly into an external frame and fill an input without violating the cross-origin frame restriction.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">chrome.webNavigation.getAllFrames({tabId: tabId}, (frames) => {\n  const frameIds = frames\n  .map((f) => f.frameId);\n\n  chrome.scripting.executeScript({\n    target: { tabId: tabId, frameIds: frameIds },\n    function: functionToInject,\n  });\n});</code></pre></div>\n<p>This will inject the function in all frames found in the page. Ofcourse further filters can be applied to the frames to target more specific frames.</p>","frontmatter":{"title":"Running scripts inside externally loaded iframe from Chrome Extension","date":"June 11, 2021","description":null}},"previous":{"fields":{"slug":"/2-elastic-beanstalk-docker/"},"frontmatter":{"title":"Using docker with elastic beanstalk is not fun!"}},"next":{"fields":{"slug":"/4-dokku/"},"frontmatter":{"title":"Setting up a react app with API using dokku"}}},"pageContext":{"id":"97cbcc47-ea42-5c85-8e01-81b04cc85a45","previousPostId":"f612488c-12d6-5a98-8816-010229b27979","nextPostId":"1fb49b1e-a059-55d2-9e93-d5a55bd81b8b"}},"staticQueryHashes":["2841359383","898691521"]}